<!DOCTYPE html>
<html>

<head>
  <title>Tetris</title>
  <style>
    body,
    html,
    input,
    button,
    textarea,
    select,
    #board,
    .cell,
    .filled,
    .active,
    #score,
    #aiInsight,
    #highScores,
    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    label,
    span,
    div {
      font-family: monospace !important;
      user-select: none !important;
      -webkit-user-select: none !important;
      -moz-user-select: none !important;
      -ms-user-select: none !important;
    }

    #board {
      line-height: 1;
    }

    .cell {
      width: 20px;
      height: 20px;
      display: inline-block;
      border: 1px solid #ccc;
    }

    .filled {
      background: #3498db;
    }

    .active {
      outline: 2px solid #e67e22;
      z-index: 2;
    }
  </style>
</head>

<body>
  <h1>Tetris</h1>
  <div>
    <span id="score">Score: 0</span>
    <button onclick="newGame()">New Game</button>
    <button id="autoBtn" onclick="toggleAutoPlay()">Auto Play</button>
    <span style="margin-left:18px;font-size:14px;">
      <b>Speed:</b>
      <label><input type="radio" name="speedMode" value="slow" checked> Slow</label>
      <label><input type="radio" name="speedMode" value="normal"> Normal</label>
      <label><input type="radio" name="speedMode" value="fast"> Fast</label>
      <label><input type="radio" name="speedMode" value="impossible">Impossible</label>
    </span>
  </div>
  <div style="display:flex;align-items:flex-start;gap:48px;margin-top:18px;">
    <div style="display:flex;flex-direction:column;align-items:flex-start;">
      <div style="display:flex;flex-direction:row;align-items:flex-start;">
        <div id="board"></div>
        <div style="margin-left:32px;">
          <div style="font-weight:bold;margin-bottom:8px;">Next Piece:</div>
          <div id="nextPiece"
            style="display:flex;align-items:center;justify-content:center;padding:8px;border:2px solid #888;border-radius:8px;background:#f8f8f8;width:100px;height:100px;box-sizing:border-box;">
          </div>
          <div id="aiInsight"
            style="margin-top:12px;font-size:13px;color:#444;background:#eef;padding:8px 10px;border-radius:6px;min-height:38px;max-width:180px;">
          </div>
        </div>
      </div>
      <div style="margin-top:24px;">
        <button id="leftBtn" onmousedown="startMoveHold(-1)" onmouseup="stopMoveHold()"
          onmouseleave="stopMoveHold()">Left</button>
        <button id="rotateBtn" onmousedown="startRotateHold()" onmouseup="stopRotateHold()"
          onmouseleave="stopRotateHold()">Rotate</button>
        <button id="rightBtn" onmousedown="startMoveHold(1)" onmouseup="stopMoveHold()"
          onmouseleave="stopMoveHold()">Right</button>
        <button id="dropBtn" onmousedown="startDropHold()" onmouseup="stopDropHold()"
          onmouseleave="stopDropHold()">Drop</button>
      </div>
    </div>
    <div style="min-width:180px;">
      <div style="font-weight:bold;">
        <h3>High Scores</h3>
      </div>
      <ol id="highScores" style="margin:0;padding-left:20px;"></ol>
    </div>
  </div>
  <canvas id="fireworks"
    style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:2000;"></canvas>
  <!-- High scores are stored here, base64 encoded -->
  <textarea id="highScoresData" style="display:none;width:100%;height:40px;"></textarea>
  <div id="playerNamePrompt"
    style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.4);align-items:center;justify-content:center;z-index:1000;">
    <div
      style="background:#fff;padding:24px 32px;border-radius:10px;box-shadow:0 2px 12px #0003;display:flex;flex-direction:column;align-items:center;">
      <div style="font-weight:bold;margin-bottom:12px;">New High Score!</div>
      <label for="playerNameInput">Enter your name:</label>
      <input id="playerNameInput" maxlength="16" style="margin:8px 0 16px 0;padding:4px 8px;" />
      <button onclick="submitPlayerName()">OK</button>
    </div>
  </div>
  <script>
    let next = null;
    let highScores = [];
    let pendingScore = null;
    // --- Counters for AI insight ---
    let shapesSeen = 0;
    let linesCompleted = 0;
    let tetrises = 0;

    const SHAPES = [
      { shape: [[1, 1, 1, 1]], color: '#00c3ff' }, // I
      { shape: [[1, 1], [1, 1]], color: '#ffe600' }, // O
      { shape: [[0, 1, 0], [1, 1, 1]], color: '#a259f7' }, // T
      { shape: [[1, 0, 0], [1, 1, 1]], color: '#0051ba' }, // J
      { shape: [[0, 0, 1], [1, 1, 1]], color: '#ff7f00' }, // L
      { shape: [[1, 1, 0], [0, 1, 1]], color: '#00d100' }, // S
      { shape: [[0, 1, 1], [1, 1, 0]], color: '#ff1e56' }  // Z
    ];
    const ROWS = 20, COLS = 10;
    let board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    let current = { shape: null, color: null, row: 0, col: 3 };
    let score = 0;
    function drawNextPiece() {
      const nextPieceDiv = document.getElementById("nextPiece");
      if (!next) { nextPieceDiv.innerHTML = ""; return; }
      let shape = next.shape;
      let rows = shape.length;
      let cols = shape[0].length;
      let html = `<div style="display:flex;flex-direction:column;justify-content:center;align-items:center;height:100%;width:100%;">`;
      for (let r = 0; r < rows; r++) {
        html += '<div style="display:flex;flex-direction:row;justify-content:center;">';
        for (let c = 0; c < cols; c++) {
          let style = shape[r][c] ?
            `background:${next.color};width:20px;height:20px;display:inline-block;border:1px solid #ccc;`
            : 'width:20px;height:20px;display:inline-block;';
          html += `<span style="${style}"></span>`;
        }
        html += '</div>';
      }
      html += '</div>';
      nextPieceDiv.innerHTML = html;
    }


    let autoPlay = false;
    let autoInterval = null;
    let aiLastDropTime = null;
    let aiTimeoutCheck = null;
    let aiStuckCounter = 0;
    let lockFrames = 0;              // counts frames while sitting on the floor
    const LOCK_DELAY_STEPS = 3;      // how many AI ticks we allow to try sliding


    let speedModes = {
      slow: 400,
      normal: 120,
      fast: 50,
      impossible: 15
    };
    let scoreMultipliers = {
      slow: 0.75,
      normal: 1,
      fast: 1.5,
      impossible: 2
    };
    let currentSpeed = 'slow';

    function getSelectedSpeedMs() {
      return speedModes[currentSpeed] || 120;
    }

    function setSpeedMode(mode) {
      currentSpeed = mode;
      if (autoPlay) {
        clearInterval(autoInterval);
        autoInterval = setInterval(autoPlayStep, getSelectedSpeedMs());
      }
    }

    function aiWatchdog() {
      if (autoPlay && Date.now() - aiLastDropTime > 5000) {
        // End game, record score, start new game
        autoPlay = false;
        clearInterval(autoInterval);
        clearInterval(aiTimeoutCheck);
        autoInterval = null;
        aiTimeoutCheck = null;
        addHighScore(score);
        setTimeout(function () {
          autoPlay = true;
          document.getElementById('autoBtn').textContent = 'Stop Auto Play';
          newGame();
          aiLastDropTime = Date.now();
          autoInterval = setInterval(autoPlayStep, getSelectedSpeedMs());
          aiTimeoutCheck = setInterval(aiWatchdog, 1000);
        }, 1000);
      }
    }

    function toggleAutoPlay() {
      autoPlay = !autoPlay;
      document.getElementById('autoBtn').textContent = autoPlay ? 'Stop Auto Play' : 'Auto Play';

      if (autoPlay) {
        aiLastDropTime = Date.now();
        autoInterval = setInterval(autoPlayStep, getSelectedSpeedMs());
        aiTimeoutCheck = setInterval(aiWatchdog, 1000);
      } else {
        clearInterval(autoInterval);
        clearInterval(aiTimeoutCheck);
        autoInterval = null;
        aiTimeoutCheck = null;
      }
    }

    function autoPlayStep() {
      if (current.row === 0) {
        const best = findBestMove();
        current.targetCol = best.col;
        current.targetRot = best.rot;
        current.rotationsLeft = best.rot;
        aiStuckCounter = 0;
      }
      updateGameStats();

      let moved = false;

      // Rotate toward target
      if (current.rotationsLeft && current.rotationsLeft > 0) {
        rotate();
        current.rotationsLeft--;
        moved = true;
      } else if (current.col < current.targetCol) {
        move(1);
        moved = true;
      } else if (current.col > current.targetCol) {
        move(-1);
        moved = true;
      }

      // Track “stuck” steps (unchanged from yours)
      if (!moved) aiStuckCounter++; else aiStuckCounter = 0;
      if (aiStuckCounter >= 10) {
        drop();
        aiLastDropTime = Date.now();
        aiStuckCounter = 0;
        lockFrames = 0; // reset lock timer
        return;
      }

      // NEW: floor slide + lock delay
      if (!canMove(1, 0)) {
        // Try to open space by sliding along the floor
        const slid = attemptFloorSlide();
        if (slid) {
          // success — we got room to fall again; reset lock timer and drop one row
          lockFrames = 0;
          drop();                    // advances one row
          aiLastDropTime = Date.now();
          return;
        }
        // No slide available — tick the lock delay
        lockFrames++;
        if (lockFrames >= LOCK_DELAY_STEPS) {
          // Time to lock the piece
          drop();                    // this will merge since we can't move down
          aiLastDropTime = Date.now();
          lockFrames = 0;
        }
        return;
      } else {
        // We can still fall — keep gravity going and clear lock timer
        lockFrames = 0;
        drop();
        aiLastDropTime = Date.now();
      }
    }

    // --- AI Helper Functions ---
    function attemptFloorSlide() {
      // If we don't know a target, nothing to do
      if (typeof current.targetCol !== 'number') return false;

      const dirToTarget = current.col < current.targetCol ? 1 : (current.col > current.targetCol ? -1 : 0);

      // Strategy:
      // 1) Try toward the target; if that doesn’t free a downward move, 
      // 2) try the opposite once (sometimes a tiny detour frees the fall).
      // We cap attempts per call to keep things snappy.
      const tryDirs = dirToTarget !== 0 ? [dirToTarget, -dirToTarget] : [-1, 1];

      for (let i = 0; i < tryDirs.length; i++) {
        const d = tryDirs[i];
        if (canMove(0, d)) {
          current.col += d;
          if (canMove(1, 0)) {
            return true; // sliding opened space below
          }
          // If moving once didn’t help, try up to 3 more short slides in same direction
          for (let step = 0; step < 3; step++) {
            if (!canMove(0, d)) break;
            current.col += d;
            if (canMove(1, 0)) return true;
          }
          // Revert if it didn’t help at all (optional—keeps piece near where it was)
          // (Comment this out if you prefer leaving it where it ended up)
          // while (canMove(0, -d)) current.col -= d;
        }
      }
      return false;
    }

    function getBumpiness(bd) {
      let heights = [];
      for (let c = 0; c < COLS; c++) {
        let h = 0;
        for (let r = 0; r < ROWS; r++) {
          if (bd[r][c]) {
            h = ROWS - r;
            break;
          }
        }
        heights.push(h);
      }
      let bump = 0;
      for (let i = 0; i < heights.length - 1; i++) {
        bump += Math.abs(heights[i] - heights[i + 1]);
      }
      return bump;
    }
    function getWellDepth(bd) {
      let total = 0;
      for (let c = 0; c < COLS; c++) {
        for (let r = 0; r < ROWS; r++) {
          if (!bd[r][c] &&
            (c === 0 || bd[r][c - 1]) &&
            (c === COLS - 1 || bd[r][c + 1])) {
            let depth = 1;
            let rr = r + 1;
            while (rr < ROWS && !bd[rr][c]) {
              depth++;
              rr++;
            }
            total += depth;
          }
        }
      }
      return total;
    }
    function getBlockades(bd) {
      let blockades = 0;
      for (let c = 0; c < COLS; c++) {
        let foundHole = false;
        for (let r = 0; r < ROWS; r++) {
          if (!bd[r][c]) foundHole = true;
          else if (foundHole) blockades++;
        }
      }
      return blockades;
    }
    function isTetrisSetup(bd) {
      for (let c of [0, COLS - 1]) {
        let well = 0;
        for (let r = ROWS - 1; r >= 0; r--) {
          if (!bd[r][c]) well++;
          else break;
        }
        if (well >= 4) return true;
      }
      return false;
    }
    let aiLastInsight = "";
    function findBestMove() {
      let bestScore = -Infinity;
      let bestCol = 0;
      let bestRot = 0;
      let bestReason = "";
      const originalShape = current.shape;
      const originalColor = current.color;
      for (let rot = 0; rot < 4; rot++) {
        let testShape = originalShape;
        for (let r = 0; r < rot; r++) {
          testShape = testShape[0].map((_, i) => testShape.map(row => row[i]).reverse());
        }
        for (let col = -2; col < COLS; col++) {
          if (!canPlaceAt(testShape, col)) continue;
          let testRow = 0;
          while (canPlaceAt(testShape, col, testRow + 1)) testRow++;
          let testBoard = board.map(row => row.slice());
          for (let tr = 0; tr < testShape.length; tr++)
            for (let tc = 0; tc < testShape[0].length; tc++)
              if (testShape[tr][tc])
                testBoard[testRow + tr][col + tc] = originalColor;
          let linesCleared = 0;
          for (let r = 0; r < ROWS; r++) {
            if (testBoard[r].every(x => x)) linesCleared++;
          }
          let maxHeight = 0;
          for (let c = 0; c < COLS; c++) {
            for (let r = 0; r < ROWS; r++) {
              if (testBoard[r][c]) {
                let h = ROWS - r;
                if (h > maxHeight) maxHeight = h;
                break;
              }
            }
          }
          let survivalMode = maxHeight > 7;
          let tetrisBonus = 0;
          let nonTetrisPenalty = 0;
          if (!survivalMode) {
            tetrisBonus = (linesCleared === 4) ? 3000 : 0;
            nonTetrisPenalty = (linesCleared > 0 && linesCleared < 4) ? -400 : 0;
          }
          let nextShape = next.shape;
          let nextColor = next.color;
          let bestNextScore = -Infinity;
          for (let nrot = 0; nrot < 4; nrot++) {
            let nShape = nextShape;
            for (let nr = 0; nr < nrot; nr++) {
              nShape = nShape[0].map((_, i) => nShape.map(row => row[i]).reverse());
            }
            for (let ncol = -2; ncol < COLS; ncol++) {
              if (!canPlaceAt(nShape, ncol, 0, testBoard)) continue;
              let nrow = 0;
              while (canPlaceAt(nShape, ncol, nrow + 1, testBoard)) nrow++;
              let nBoard = testBoard.map(row => row.slice());
              for (let tr = 0; tr < nShape.length; tr++)
                for (let tc = 0; tc < nShape[0].length; tc++)
                  if (nShape[tr][tc])
                    nBoard[nrow + tr][ncol + tc] = nextColor;
              let nLinesCleared = 0;
              for (let r = 0; r < ROWS; r++) {
                if (nBoard[r].every(x => x)) nLinesCleared++;
              }
              let nScore =
                -getAggregateHeight(nBoard) * 0.7
                - getHoles(nBoard) * 7
                - getBumpiness(nBoard) * 1.5
                - getWellDepth(nBoard) * 1.2
                - getBlockades(nBoard) * 2
                + nLinesCleared * 120
                + (isTetrisSetup(nBoard) ? 100 : 0);
              if (nScore > bestNextScore) bestNextScore = nScore;
            }
          }
          let tetrisSetupBonus = (!survivalMode && isTetrisSetup(testBoard)) ? 800 : 0;
          let filledWellPenalty = 0;
          if (!survivalMode) {
            for (let c of [0, COLS - 1]) {
              let well = 0;
              for (let r = ROWS - 1; r >= 0; r--) {
                if (!testBoard[r][c]) well++;
                else break;
              }
              if (well < 4) filledWellPenalty -= 300;
            }
          }
          let highStackPenalty = (maxHeight > 15) ? (maxHeight - 15) * -200 : 0;
          let score;
          if (survivalMode) {
            score =
              -getAggregateHeight(testBoard) * 0.7
              - getHoles(testBoard) * 7
              - getBumpiness(testBoard) * 1.5
              - getWellDepth(testBoard) * 1.2
              - getBlockades(testBoard) * 2
              + linesCleared * 200
              + bestNextScore * 0.5
              + highStackPenalty;
          } else {
            score =
              -getAggregateHeight(testBoard) * 0.7
              - getHoles(testBoard) * 7
              - getBumpiness(testBoard) * 1.5
              - getWellDepth(testBoard) * 1.2
              - getBlockades(testBoard) * 2
              + bestNextScore * 0.5
              + tetrisBonus
              + tetrisSetupBonus
              + nonTetrisPenalty
              + filledWellPenalty
              + highStackPenalty;
          }
          if (score > bestScore) {
            bestScore = score;
            bestCol = col;
            bestRot = rot;
            if (survivalMode) {
              if (linesCleared > 0) {
                bestReason = `Survival mode: clearing ${linesCleared} line${linesCleared > 1 ? 's' : ''} to lower stack.`;
              } else {
                bestReason = `Survival mode: minimizing danger, best stack height: ${maxHeight}.`;
              }
            } else {
              if (linesCleared === 4) {
                bestReason = `Going for Tetris! 4 lines cleared.`;
              } else if (isTetrisSetup(testBoard)) {
                bestReason = `Setting up for Tetris (deep well).`;
              } else if (linesCleared > 0) {
                bestReason = `Clearing ${linesCleared} line${linesCleared > 1 ? 's' : ''} (no Tetris possible).`;
              } else {
                bestReason = `Best position for future Tetris.`;
              }
            }
          }
        }
      }
      if (bestScore === -Infinity) {
        bestScore = -Infinity;
        for (let rot = 0; rot < 4; rot++) {
          let testShape = originalShape;
          for (let r = 0; r < rot; r++) {
            testShape = testShape[0].map((_, i) => testShape.map(row => row[i]).reverse());
          }
          for (let col = -2; col < COLS; col++) {
            if (!canPlaceAt(testShape, col)) continue;
            let testRow = 0;
            while (canPlaceAt(testShape, col, testRow + 1)) testRow++;
            let testBoard = board.map(row => row.slice());
            for (let tr = 0; tr < testShape.length; tr++)
              for (let tc = 0; tc < testShape[0].length; tc++)
                if (testShape[tr][tc])
                  testBoard[testRow + tr][col + tc] = originalColor;
            let linesCleared = 0;
            for (let r = 0; r < ROWS; r++) {
              if (testBoard[r].every(x => x)) linesCleared++;
            }
            let score =
              -getAggregateHeight(testBoard) * 0.7
              - getHoles(testBoard) * 7
              - getBumpiness(testBoard) * 1.5
              - getWellDepth(testBoard) * 1.2
              - getBlockades(testBoard) * 2
              + linesCleared * 120;
            if (score > bestScore) {
              bestScore = score;
              bestCol = col;
              bestRot = rot;
            }
          }
        }
      }
      aiLastInsight = bestReason;
      return { col: bestCol, rot: bestRot };
    }
    function canPlaceAt(shape, col, row = 0, customBoard = null) {
      let bd = customBoard || board;
      for (let r = 0; r < shape.length; r++)
        for (let c = 0; c < shape[0].length; c++)
          if (shape[r][c]) {
            let nr = row + r, nc = col + c;
            if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS || bd[nr][nc]) return false;
          }
      return true;
    }
    function getAggregateHeight(bd) {
      let total = 0;
      for (let c = 0; c < COLS; c++) {
        for (let r = 0; r < ROWS; r++) {
          if (bd[r][c]) {
            total += (ROWS - r);
            break;
          }
        }
      }
      return total;
    }
    function getHoles(bd) {
      let holes = 0;
      for (let c = 0; c < COLS; c++) {
        let block = false;
        for (let r = 0; r < ROWS; r++) {
          if (bd[r][c]) block = true;
          else if (block && !bd[r][c]) holes++;
        }
      }
      return holes;
    }

    function getColumnHeights(bd) {
      const heights = new Array(COLS).fill(0);
      for (let c = 0; c < COLS; c++) {
        for (let r = 0; r < ROWS; r++) {
          if (bd[r][c]) { heights[c] = ROWS - r; break; }
        }
      }
      return heights;
    }

    function newPiece() {
      if (!next) {
        next = SHAPES[Math.floor(Math.random() * SHAPES.length)];
      }
      current = { shape: next.shape, color: next.color, row: 0, col: 3 };
      next = SHAPES[Math.floor(Math.random() * SHAPES.length)];
      drawNextPiece();
      shapesSeen++;
      updateGameStats();
      if (!canMove(0, 0, current.shape)) {
        addHighScore(score);
        if (autoPlay) {
          setTimeout(() => { newGame(); }, 500);
        } else {
          alert("Game Over! Your score: " + score);
        }
        board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        score = 0;
        updateScore();
      }
    }
    function canMove(dr, dc, shape = current.shape) {
      for (let r = 0; r < shape.length; r++)
        for (let c = 0; c < shape[0].length; c++)
          if (shape[r][c]) {
            let nr = current.row + r + dr, nc = current.col + c + dc;
            if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS || board[nr][nc]) return false;
          }
      return true;
    }
    function merge() {
      for (let r = 0; r < current.shape.length; r++)
        for (let c = 0; c < current.shape[0].length; c++)
          if (current.shape[r][c])
            board[current.row + r][current.col + c] = current.color;
      let linesCleared = 0;
      for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r].every(x => x)) {
          board.splice(r, 1);
          board.unshift(Array(COLS).fill(0));
          linesCleared++;
          r++;
        }
      }
      if (linesCleared > 0) {
        let bonus = 0;
        if (linesCleared === 4) {
          bonus = 800;
          tetrises++;
          showFireworks();

        }
        let multiplier = scoreMultipliers[currentSpeed] || 1;
        score += Math.round((linesCleared * 100 + bonus) * multiplier);
        linesCompleted += linesCleared;
        updateScore();
        updateGameStats();
      }
    }
    function updateGameStats() {
      const statsDiv = document.getElementById('aiInsight');
      if (!statsDiv) return;

      const heights = getColumnHeights(board);
      const avgHeight = heights.reduce((a, b) => a + b, 0) / COLS;
      const maxHeight = heights.reduce((a, b) => a > b ? a : b, 0);
      const mult = scoreMultipliers[currentSpeed] || 1;

      statsDiv.innerHTML = `
    <div><b>Game Stats</b></div>
    <div style="margin-top:6px;line-height:1.4">
      Lines completed: <b>${linesCompleted}</b><br>
      Tetrises: <b>${tetrises}</b><br>
      Shapes seen: <b>${shapesSeen}</b><br>
      Avg board height: <b>${avgHeight.toFixed(1)}</b><br>
      Current board height: <b>${maxHeight}</b><br>
      Speed: <b>${currentSpeed}</b> &nbsp; Multiplier: <b>×${mult}</b>
    </div>
  `;
    }

    function newGame() {
      board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
      score = 0;
      shapesSeen = 0;
      linesCompleted = 0;
      tetrises = 0;
      updateScore();
      next = null;
      newPiece();
      draw();
      updateGameStats();
    }
    function updateScore() {
      document.getElementById("score").textContent = "Score: " + score;
    }
    function move(dir) {
      if (canMove(0, dir)) current.col += dir;
      draw();
    }
    function rotate() {
      const shape = current.shape[0].map((_, i) => current.shape.map(row => row[i]).reverse());
      if (canMove(0, 0, shape)) current.shape = shape;
      draw();
    }
    function drop() {
      if (canMove(1, 0)) {
        current.row++;
        draw();
      } else {
        merge();
        newPiece();
        draw();
      }
    }
    let dropInterval = null;
    function startDropHold() {
      if (dropInterval) return;
      drop();
      dropInterval = setInterval(drop, 40);
    }
    function stopDropHold() {
      clearInterval(dropInterval);
      dropInterval = null;
    }
    let moveInterval = null;
    function startMoveHold(dir) {
      if (moveInterval) return;
      move(dir);
      moveInterval = setInterval(() => move(dir), 120);
    }
    function stopMoveHold() {
      clearInterval(moveInterval);
      moveInterval = null;
    }
    let rotateInterval = null;
    function startRotateHold() {
      if (rotateInterval) return;
      rotate();
      rotateInterval = setInterval(rotate, 250);
    }
    function stopRotateHold() {
      clearInterval(rotateInterval);
      rotateInterval = null;
    }
    function draw() {
      let html = "";
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          let color = board[r][c];
          let active = false;
          let activeColor = null;
          for (let rr = 0; rr < current.shape.length; rr++)
            for (let cc = 0; cc < current.shape[0].length; cc++)
              if (current.shape[rr][cc] && r == current.row + rr && c == current.col + cc) {
                active = true;
                activeColor = current.color;
              }
          let style = '';
          if (active) {
            style = `background:${activeColor};outline:2px solid #e67e22;z-index:2;`;
          } else if (color) {
            style = `background:${color};`;
          }
          html += `<span class="cell${active ? ' active' : color ? ' filled' : ''}" style="${style}" data-row="${r}" data-col="${c}"></span>`;
        }
        html += "<br>";
      }
      document.getElementById("board").innerHTML = html;
    }
    function showFireworks() {
      const canvas = document.getElementById('fireworks');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      canvas.style.display = 'block';
      let ctx = canvas.getContext('2d');
      let particles = [];
      let colors = ['#ff5252', '#ffd700', '#00e6ff', '#a259f7', '#00d100', '#ff7f00'];
      function createFirework() {
        let x = Math.random() * canvas.width * 0.6 + canvas.width * 0.2;
        let y = Math.random() * canvas.height * 0.3 + canvas.height * 0.2;
        let color = colors[Math.floor(Math.random() * colors.length)];
        for (let i = 0; i < 32; i++) {
          let angle = (Math.PI * 2 * i) / 32;
          let speed = Math.random() * 4 + 2;
          particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            alpha: 1,
            color
          });
        }
      }
      for (let i = 0; i < 3; i++) createFirework();
      let frame = 0;
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let p of particles) {
          ctx.globalAlpha = p.alpha;
          ctx.beginPath();
          ctx.arc(p.x, p.y, 3, 0, 2 * Math.PI);
          ctx.fillStyle = p.color;
          ctx.fill();
        }
        for (let p of particles) {
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.96;
          p.vy *= 0.96;
          p.vy += 0.05;
          p.alpha *= 0.96;
        }
        frame++;
        if (frame < 60) {
          requestAnimationFrame(animate);
        } else {
          canvas.style.display = 'none';
        }
      }
      animate();
    }
    // High score and player name logic
    function addHighScore(newScore) {
      if (newScore <= 0) return;
      if (autoPlay) {
        saveHighScore({ name: 'AI', score: newScore });
      } else {
        pendingScore = newScore;
        showPlayerNamePrompt();
      }
    }
    function showPlayerNamePrompt() {
      document.getElementById('playerNamePrompt').style.display = 'flex';
      document.getElementById('playerNameInput').value = '';
      setTimeout(() => { document.getElementById('playerNameInput').focus(); }, 100);
    }
    function submitPlayerName() {
      const name = document.getElementById('playerNameInput').value.trim() || 'Player';
      document.getElementById('playerNamePrompt').style.display = 'none';
      if (pendingScore !== null) {
        saveHighScore({ name, score: pendingScore });
        pendingScore = null;
      }
    }
    function encodeScores(scores) {
      const json = JSON.stringify(scores);
      return btoa(String.fromCharCode(...new TextEncoder().encode(json)));
    }
    function decodeScores(str) {
      try {
        const bytes = Uint8Array.from(atob(str), c => c.charCodeAt(0));
        return JSON.parse(new TextDecoder().decode(bytes));
      } catch (e) { return []; }
    }

    function saveHighScore(entry) {
      highScores.push(entry);
      highScores.sort((a, b) => b.score - a.score);
      if (highScores.length > 10) highScores.length = 10;
      updateHighScores();
      // Save to localStorage as before
      localStorage.setItem('tetrisHighScores', JSON.stringify(highScores));
      // Save to hidden textarea, encrypted
      document.getElementById('highScoresData').value = encodeScores(highScores);
    }
    function updateHighScores() {
      const ol = document.getElementById("highScores");
      ol.innerHTML = highScores.map(s => `<li><b>${escapeHtml(s.name)}</b>: ${s.score}</li>`).join("");
    }
    function escapeHtml(str) {
      return String(str).replace(/[&<>"']/g, function (c) {
        return { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c];
      });
    }
    function loadHighScores() {
      // Try to load from hidden textarea first
      const ta = document.getElementById('highScoresData');
      let loaded = false;
      if (ta && ta.value) {
        const decoded = decodeScores(ta.value);
        if (Array.isArray(decoded)) {
          highScores = decoded;
          loaded = true;
        }
      }
      if (!loaded) {
        try {
          const data = localStorage.getItem('tetrisHighScores');
          if (data) {
            highScores = JSON.parse(data);
          }
        } catch (e) { highScores = []; }
      }
      updateHighScores();
      // Sync textarea with latest
      if (ta) ta.value = encodeScores(highScores);
    }
    // Mouse drag and click for moving/rotating pieces
    let dragStartX = null;
    let dragStartY = null;
    let dragging = false;
    let lastDragCol = null;
    let pieceDroppedByDrag = false;
    document.addEventListener("mousedown", function (e) {
      if (e.button !== 0) return;
      dragStartX = e.clientX;
      dragStartY = e.clientY;
      lastDragCol = current.col;
      dragging = true;
      pieceDroppedByDrag = false;
    });
    document.addEventListener("mousemove", function (e) {
      if (!dragging) return;
      let dx = e.clientX - dragStartX;
      let dy = e.clientY - dragStartY;
      let cellWidth = 20;
      let moveBy = Math.round(dx / cellWidth);
      let newCol = lastDragCol + moveBy;
      if (newCol !== current.col && canMove(0, newCol - current.col)) {
        current.col = newCol;
        draw();
      }
      if (!pieceDroppedByDrag && dy > 30) {
        while (canMove(1, 0)) {
          current.row++;
        }
        merge();
        newPiece();
        draw();
        pieceDroppedByDrag = true;
        dragging = false;
      }
    });
    document.addEventListener("mouseup", function (e) {
      if (!dragging) return;
      dragging = false;
    });
    document.addEventListener("wheel", function (e) {
      e.preventDefault();
      rotate();
    }, { passive: false });
    document.addEventListener("mouseleave", function (e) {
      dragging = false;
    });
    document.addEventListener("contextmenu", function (e) {
      e.preventDefault();
    });
    document.addEventListener('DOMContentLoaded', function () {
      updateGameStats();
      // Set up speed mode radio buttons
      document.querySelectorAll('input[name="speedMode"]').forEach(radio => {
        radio.addEventListener('change', function () {
          if (this.checked) setSpeedMode(this.value);
        });
      });
    });
    newPiece();
    draw();
    loadHighScores();
  </script>
</body>

</html>