<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Tetris</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --cols: 10;
      --rows: 20;
      --cell: 20px;
    }

    * {
      box-sizing: border-box;
    }

    body,
    html,
    input,
    button,
    textarea,
    select,
    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    label,
    span,
    div {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace !important;
      user-select: none !important;
    }

    .wrap {
      display: flex;
      align-items: flex-start;
      gap: 48px;
      margin-top: 18px;
    }

    #boardCanvas {
      border: 1px solid #bbb;
      image-rendering: pixelated;
    }

    #nextCanvas {
      display: block;
      border: 2px solid #888;
      border-radius: 8px;
      background: #f8f8f8;
    }

    #gameStats {
      margin-top: 12px;
      font-size: 13px;
      color: #444;
      background: #eef;
      padding: 8px 10px;
      border-radius: 6px;
      min-height: 38px;
      max-width: 220px;
    }

    #resetHighScoresBtn {
      position: fixed;
      bottom: 12px;
      left: 12px;
      z-index: 9999;
      opacity: .35;
      font-size: 12px;
      padding: 4px 10px;
      background: #eee;
      border: 1px solid #bbb;
      border-radius: 6px;
      color: #444;
      cursor: pointer;
      transition: opacity .2s;
    }

    #resetHighScoresBtn:hover {
      opacity: .7;
    }

    #playerNamePrompt {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, .4);
      z-index: 1000;
    }

    #playerNamePrompt .dialog {
      background: #fff;
      padding: 24px 32px;
      border-radius: 10px;
      box-shadow: 0 2px 12px #0003;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    #fireworks {
      display: none;
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 2000;
    }

    ol#highScores {
      margin: 0;
      padding-left: 20px;
    }

    ol#highScores li {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 200px;
    }

    .btns {
      margin-top: 24px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
  </style>
</head>

<body>
  <h1>Tetris</h1>

  <div>
    <span id="score">Score: 0</span>
    <button id="btnNew">New Game</button>
    <button id="autoBtn">Auto Play</button>
    <span style="margin-left:18px;font-size:14px;">
      <b>Speed:</b>
      <label><input type="radio" name="speedMode" value="Slow" checked> Slow</label>
      <label><input type="radio" name="speedMode" value="Normal"> Normal</label>
      <label><input type="radio" name="speedMode" value="Fast"> Fast</label>
      <label><input type="radio" name="speedMode" value="Impossible"> Impossible</label>
    </span>
  </div>

  <div class="wrap">
    <div>
      <div style="display:flex;align-items:flex-start;gap:24px;">
        <canvas id="boardCanvas" width="200" height="400" aria-label="Tetris board"></canvas>
        <div>
          <div style="font-weight:bold;margin-bottom:8px;">Next Piece:</div>
          <canvas id="nextCanvas" width="100" height="100"></canvas>
          <div id="gameStats"></div>
        </div>
      </div>
      <div class="btns">
        <button id="btnLeft">Left</button>
        <button id="btnRotate">Rotate</button>
        <button id="btnRight">Right</button>
        <button id="btnDrop">Drop</button>
      </div>
    </div>

    <div style="min-width:220px;">
      <div style="font-weight:bold;">
        <h3>High Scores</h3>
      </div>
      <ol id="highScores"></ol>
    </div>
  </div>

  <canvas id="fireworks"></canvas>
  <textarea id="highScoresData" style="display:none;width:100%;height:40px;"></textarea>
  <button id="resetHighScoresBtn">Reset High Scores</button>

  <div id="playerNamePrompt" role="dialog" aria-modal="true">
    <div class="dialog">
      <div style="font-weight:bold;">New High Score!</div>
      <label for="playerNameInput">Enter your name:</label>
      <input id="playerNameInput" maxlength="24" style="padding:4px 8px;" />
      <button id="btnNameOk">OK</button>
    </div>
  </div>

  <script>
    (() => {
      // ---------- Config ----------
      const COLS = 10, ROWS = 20, CELL = 20;
      const SPEED_MS = { Slow: 400, Normal: 120, Fast: 50, Impossible: 15 };
      const SCORE_MULT = { Slow: 0.75, Normal: 1, Fast: 1.5, Impossible: 2 };
      const LOCK_DELAY_STEPS = 3;     // ticks while resting before lock
      const SLIDE_MAX = 4;            // search radius for floor slide
      const SLIDE_IMPROVE = 80;       // min heuristic improvement to allow slide

      // ---------- Elements ----------
      const $ = s => document.querySelector(s);
      const boardCV = $('#boardCanvas');
      const board = boardCV.getContext('2d');
      const nextCV = $('#nextCanvas');
      const nextCtx = nextCV.getContext('2d');
      const fireworksCV = $('#fireworks');
      const scoreEl = $('#score');
      const statsEl = $('#gameStats');
      const autoBtn = $('#autoBtn');

      // ---------- Game Data ----------
      const SHAPES = [
        { shape: [[1, 1, 1, 1]], color: '#00c3ff' },            // I
        { shape: [[1, 1], [1, 1]], color: '#ffe600' },          // O
        { shape: [[0, 1, 0], [1, 1, 1]], color: '#a259f7' },      // T
        { shape: [[1, 0, 0], [1, 1, 1]], color: '#0051ba' },      // J
        { shape: [[0, 0, 1], [1, 1, 1]], color: '#ff7f00' },      // L
        { shape: [[1, 1, 0], [0, 1, 1]], color: '#00d100' },      // S
        { shape: [[0, 1, 1], [1, 1, 0]], color: '#ff1e56' }       // Z
      ];

      // ---------- State ----------
      const State = { ATTRACT: 'ATTRACT', PLAYING: 'PLAYING' };
      let state = State.ATTRACT;

      let grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
      let current = { shape: null, color: null, row: 0, col: 3 };
      let next = null;
      let score = 0, shapesSeen = 0, linesCompleted = 0, tetrises = 0;
      let currentSpeed = 'Slow', lineBonusMultiplier = 1;

      // gravity/lock
      let lockSteps = 0;
      let gravityAccum = 0;

      // main loop
      let lastTs = 0;
      let rafId = 0;

      // high scores
      let highScores = [];
      let pendingScore = null;

      // attract
      const BANNER = ["LET'S", "PLAY", "TETRIS!"]; // centered 3 lines
      const ATTR_TICK = 120, ATTR_PAUSE = 1500;
      let attrMsg = BANNER.slice();
      let attrX = COLS, attrY = centerY(attrMsg.length), attrMode = 'scroll';
      let attrColor = randColor();
      let attrTimer = 0, attrPauseTimer = 0;
      let attrIter = null;

      // AI
      let autoPlay = false;
      let aiCooldown = 0;              // ms between AI actions
      const AI_STEP_MS = 50;
      let aiTarget = null;             // {col, rot}, rotationsLeft

      // ---------- Utils ----------
      const deepCopy = m => m.map(r => r.slice());
      const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
      const rotateMatrix = m => m[0].map((_, i) => m.map(r => r[i]).reverse());
      const randColor = () => SHAPES[Math.floor(Math.random() * SHAPES.length)].color;
      function escapeHtml(str) {
        return String(str).replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[c]));
      }

      // ---------- Rendering ----------
      function drawBoard() {
        // clear
        board.clearRect(0, 0, boardCV.width, boardCV.height);
        // fixed blocks
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            const color = grid[r][c];
            if (color) drawCell(c, r, color);
          }
        }
        // active piece
        if (current.shape) {
          for (let r = 0; r < current.shape.length; r++) {
            for (let c = 0; c < current.shape[0].length; c++) {
              if (current.shape[r][c]) drawCell(current.col + c, current.row + r, current.color, true);
            }
          }
        }
      }
      function drawCell(c, r, color, active = false) {
        const x = c * CELL, y = r * CELL;
        board.fillStyle = color;
        board.fillRect(x, y, CELL, CELL);
        // bevel
        board.globalAlpha = 0.18;
        board.fillStyle = '#000';
        board.fillRect(x, y + CELL - 2, CELL, 2);
        board.fillRect(x + CELL - 2, y, 2, CELL);
        board.globalAlpha = 1;
        if (active) {
          // outline
          board.strokeStyle = '#e67e22';
          board.lineWidth = 2;
          board.strokeRect(x + 1, y + 1, CELL - 2, CELL - 2);
        }
      }

      function drawNext() {
        nextCtx.clearRect(0, 0, nextCV.width, nextCV.height);
        if (!next) return;
        const s = next.shape, color = next.color;
        const cell = 20;
        const rows = s.length, cols = s[0].length;
        const totalW = cols * cell, totalH = rows * cell;
        const offX = Math.floor((nextCV.width - totalW) / 2);
        const offY = Math.floor((nextCV.height - totalH) / 2);
        nextCtx.fillStyle = color;
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            if (s[r][c]) nextCtx.fillRect(offX + c * cell, offY + r * cell, cell, cell);
          }
        }
      }

      // Text drawn in attract mode
      function drawAttract() {
        board.clearRect(0, 0, boardCV.width, boardCV.height);
        board.fillStyle = attrColor;
        board.textBaseline = 'middle';
        board.textAlign = 'center';
        board.font = 'bold 14px monospace';

        const widths = attrMsg.map(s => s.length);
        const maxW = Math.max(...widths);
        const offsets = widths.map(w => Math.floor((maxW - w) / 2));

        for (let i = 0; i < attrMsg.length; i++) {
          const line = attrMsg[i];
          for (let j = 0; j < line.length; j++) {
            const c = line[j];
            const col = attrX + j + offsets[i];
            const row = attrY + i;
            if (col < 0 || col >= COLS || row < 0 || row >= ROWS) continue;
            const x = col * CELL, y = row * CELL;
            // colored tile + letter
            board.fillStyle = attrColor;
            board.fillRect(x, y, CELL, CELL);
            board.fillStyle = '#111';
            board.fillText(c, x + CELL / 2, y + CELL / 2 + 1);
          }
        }
      }

      function renderStats() {
        const heights = getColumnHeights(grid);
        const avg = heights.reduce((a, b) => a + b, 0) / COLS;
        const max = Math.max(...heights, 0);
        const mult = ((SCORE_MULT[currentSpeed] || 1) * lineBonusMultiplier).toFixed(3);
        statsEl.innerHTML = `
      <div><b>Game Stats</b></div>
      <div style="margin-top:6px;line-height:1.4">
        Lines completed: <b>${linesCompleted}</b><br>
        Tetrises: <b>${tetrises}</b><br>
        Shapes seen: <b>${shapesSeen}</b><br>
        Avg board height: <b>${avg.toFixed(1)}</b><br>
        Current board height: <b>${max}</b><br>
        Speed: <b>${currentSpeed}</b> &nbsp; Multiplier: <b>Ã—${mult}</b>
      </div>`;
      }
      function setScoreUI() { scoreEl.textContent = `Score: ${score}`; }

      // ---------- Game Core ----------
      function setSpeed(mode) {
        currentSpeed = (mode in SPEED_MS) ? mode : 'Normal';
      }
      function gravityMs() { return SPEED_MS[currentSpeed] || 120; }

      function canPlaceAt(shape, row, col, bd = grid) {
        for (let r = 0; r < shape.length; r++) {
          for (let c = 0; c < shape[0].length; c++) {
            if (!shape[r][c]) continue;
            const rr = row + r, cc = col + c;
            if (rr < 0 || rr >= ROWS || cc < 0 || cc >= COLS) return false;
            if (bd[rr][cc]) return false;
          }
        }
        return true;
      }
      function spawnPiece() {
        if (!next) next = SHAPES[Math.floor(Math.random() * SHAPES.length)];
        current = { shape: next.shape.map(r => r.slice()), color: next.color, row: 0, col: 3 };
        next = SHAPES[Math.floor(Math.random() * SHAPES.length)];
        drawNext();
        shapesSeen++;
        renderStats();
        // check spawn collision => game over
        if (!canPlaceAt(current.shape, current.row, current.col)) {
          addHighScore(score);
          if (autoPlay) { startNewGame(); }
          else {
            alert(`Game Over! Your score: ${score}`);
            enterAttract();
          }
        }
        // AI new target on spawn
        aiTarget = null;
      }
      function hardDrop() {
        while (canPlaceAt(current.shape, current.row + 1, current.col)) current.row++;
        lockPiece();
      }
      function lockPiece() {
        // merge
        for (let r = 0; r < current.shape.length; r++) {
          for (let c = 0; c < current.shape[0].length; c++) {
            if (current.shape[r][c]) grid[current.row + r][current.col + c] = current.color;
          }
        }
        // clear lines
        let cleared = 0;
        for (let r = ROWS - 1; r >= 0; r--) {
          if (grid[r].every(x => !!x)) {
            grid.splice(r, 1);
            grid.unshift(Array(COLS).fill(0));
            cleared++; r++;
          }
        }
        if (cleared) {
          let bonus = 0;
          if (cleared === 4) { bonus = 800; tetrises++; fireworksOnce(); }
          linesCompleted += cleared;
          lineBonusMultiplier = 1 + linesCompleted * 0.001;
          const mult = (SCORE_MULT[currentSpeed] || 1) * lineBonusMultiplier;
          score += Math.round((cleared * 100 + bonus) * mult);
          setScoreUI(); renderStats();
        }
        // next
        spawnPiece();
        lockSteps = 0;
      }

      function tryRotate() {
        const rot = rotateMatrix(current.shape);
        const kicks = [0, -1, 1, -2, 2];
        for (const k of kicks) {
          const nc = current.col + k;
          if (canPlaceAt(rot, current.row, nc)) {
            current.shape = rot;
            current.col = nc;
            lockSteps = 0;
            return true;
          }
        }
        return false;
      }
      function tryMove(dx) {
        const nc = current.col + dx;
        if (canPlaceAt(current.shape, current.row, nc)) {
          current.col = nc;
          lockSteps = 0;
          return true;
        }
        return false;
      }

      function dropStep() {
        if (canPlaceAt(current.shape, current.row + 1, current.col)) {
          current.row++;
          lockSteps = 0;
          return;
        }
        // blocked below: consider smart slide
        if (attemptSmartFloorSlide()) {
          // slid + moved down
          lockSteps = 0;
          return;
        }
        // lock delay
        lockSteps++;
        if (lockSteps >= LOCK_DELAY_STEPS) lockPiece();
      }

      // ---------- Heuristics (for AI and slide) ----------
      function getColumnHeights(bd) {
        const h = new Array(COLS).fill(0);
        for (let c = 0; c < COLS; c++) {
          for (let r = 0; r < ROWS; r++) {
            if (bd[r][c]) { h[c] = ROWS - r; break; }
          }
        }
        return h;
      }
      function getAggregateHeight(bd) { return getColumnHeights(bd).reduce((a, b) => a + b, 0); }
      function getHoles(bd) {
        let holes = 0;
        for (let c = 0; c < COLS; c++) {
          let block = false;
          for (let r = 0; r < ROWS; r++) {
            if (bd[r][c]) block = true; else if (block) holes++;
          }
        }
        return holes;
      }
      function getBumpiness(bd) {
        const h = getColumnHeights(bd);
        let s = 0; for (let i = 0; i < h.length - 1; i++) s += Math.abs(h[i] - h[i + 1]);
        return s;
      }
      function getWellDepth(bd) {
        let total = 0;
        for (let c = 0; c < COLS; c++) {
          for (let r = 0; r < ROWS; r++) {
            if (!bd[r][c] && (c === 0 || bd[r][c - 1]) && (c === COLS - 1 || bd[r][c + 1])) {
              let d = 1, rr = r + 1;
              while (rr < ROWS && !bd[rr][c]) { d++; rr++; }
              total += d;
            }
          }
        }
        return total;
      }
      function isTetrisSetup(bd) {
        for (const c of [0, COLS - 1]) {
          let well = 0;
          for (let r = ROWS - 1; r >= 0; r--) { if (!bd[r][c]) well++; else break; }
          if (well >= 4) return true;
        }
        return false;
      }
      function evalBoard(bd, linesCleared) {
        let maxH = 0;
        for (let c = 0; c < COLS; c++) {
          for (let r = 0; r < ROWS; r++) { if (bd[r][c]) { maxH = Math.max(maxH, ROWS - r); break; } }
        }
        const survival = maxH > 7;
        const tetrisBonus = (!survival && linesCleared === 4) ? 3000 : 0;
        const nonTetrisPenalty = (!survival && linesCleared > 0 && linesCleared < 4) ? -400 : 0;
        const setupBonus = (!survival && isTetrisSetup(bd)) ? 800 : 0;

        return (- getAggregateHeight(bd) * 0.7
          - getHoles(bd) * 7
          - getBumpiness(bd) * 1.5
          - getWellDepth(bd) * 1.2
          + (survival ? 200 * linesCleared : 0)
          + tetrisBonus + setupBonus + nonTetrisPenalty);
      }
      function simulateLock(bd, shape, row, col, color) {
        const tb = bd.map(r => r.slice());
        for (let r = 0; r < shape.length; r++)
          for (let c = 0; c < shape[0].length; c++)
            if (shape[r][c]) tb[row + r][col + c] = color || 1;
        // clear lines
        let lines = 0;
        for (let r = ROWS - 1; r >= 0; r--) {
          if (tb[r].every(x => !!x)) { tb.splice(r, 1); tb.unshift(Array(COLS).fill(0)); lines++; r++; }
        }
        return { board: tb, linesCleared: lines };
      }

      // Smart floor slide: only if it improves the heuristic AND does not add holes.
      function attemptSmartFloorSlide() {
        // Must be blocked below
        if (canPlaceAt(current.shape, current.row + 1, current.col)) return false;

        // Baseline = lock here (no slide)
        const baseSim = simulateLock(grid, current.shape, current.row, current.col, current.color);
        const baseScore = evalBoard(baseSim.board, baseSim.linesCleared);
        const baseHoles = getHoles(baseSim.board);

        let best = null;

        for (const dir of [1, -1]) {
          for (let step = 1; step <= SLIDE_MAX; step++) {
            const testCol = current.col + dir * step;
            // must be able to move sideways step-by-step at current.row
            if (!canPlaceAt(current.shape, current.row, testCol, grid)) break;

            // after moving sideways, must be able to go down at least one
            if (!canPlaceAt(current.shape, current.row + 1, testCol, grid)) continue;

            // let it fall from there
            let r = current.row;
            while (canPlaceAt(current.shape, r + 1, testCol, grid)) r++;

            const sim = simulateLock(grid, current.shape, r, testCol, current.color);
            const s = evalBoard(sim.board, sim.linesCleared);
            const holes = getHoles(sim.board);

            // choose better boards; require improvement threshold and no extra holes
            if (s >= baseScore + SLIDE_IMPROVE && holes <= baseHoles) {
              const fall = r - current.row;
              const choiceScore = s + fall * 15; // prefer deeper drops
              if (!best || choiceScore > best.choiceScore) {
                best = { col: testCol, row: r, choiceScore };
              }
            }
          }
        }

        if (best) {
          current.col = best.col;
          // step down one row this tick; gravity will keep pulling
          current.row++;
          return true;
        }
        return false;
      }

      // ---------- AI ----------
      function findBestMove() {
        let bestScore = -Infinity, bestCol = 0, bestRot = 0;
        const origShape = current.shape, origColor = current.color;
        for (let rot = 0; rot < 4; rot++) {
          let testShape = origShape;
          for (let r = 0; r < rot; r++) testShape = rotateMatrix(testShape);
          for (let col = -2; col < COLS; col++) {
            if (!canPlaceAt(testShape, 0, col)) continue;
            let row = 0;
            while (canPlaceAt(testShape, row + 1, col)) row++;
            const sim = simulateLock(grid, testShape, row, col, origColor);
            const score = evalBoard(sim.board, sim.linesCleared);
            if (score > bestScore) { bestScore = score; bestCol = col; bestRot = rot; }
          }
        }
        return { col: bestCol, rot: bestRot };
      }

      function aiStep(dt) {
        if (!autoPlay || state !== State.PLAYING || !current.shape) return;
        aiCooldown -= dt;
        if (aiCooldown > 0) return;
        aiCooldown = AI_STEP_MS;

        if (!aiTarget) {
          const best = findBestMove();
          aiTarget = { col: best.col, rotationsLeft: best.rot };
        }

        // rotate towards target
        if (aiTarget.rotationsLeft && aiTarget.rotationsLeft > 0) {
          if (tryRotate()) aiTarget.rotationsLeft--;
          return;
        }
        // move towards target
        if (current.col < aiTarget.col) { tryMove(1); return; }
        if (current.col > aiTarget.col) { tryMove(-1); return; }
        // aligned: let gravity handle down; if resting, smart slide may kick in in dropStep()
      }

      // ---------- Attract Mode ----------
      function centerY(lines) { return Math.floor((ROWS - lines) / 2); }
      function centerXFor(linesArr) { const w = Math.max(...linesArr.map(s => s.length)); return Math.floor((COLS - w) / 2); }

      function* makeAttractQueue() {
        yield BANNER;
        const scores = highScores.slice(0, 10);
        for (const s of scores) {
          const lines = makeHighScoreLines(s);
          yield lines;
        }
      }
      function wrapName(name, maxWidth, maxLines) {
        if (name.length <= maxWidth) return [name];
        const words = name.split(/\s+/);
        const lines = [], push = () => { if (cur) lines.push(cur); cur = ''; };
        let cur = '';
        for (const w of words) {
          if ((cur ? cur.length + 1 : 0) + w.length <= maxWidth) cur = cur ? (cur + ' ' + w) : w;
          else { push(); cur = (w.length > maxWidth) ? w.slice(0, maxWidth) : w; }
          if (lines.length === maxLines - 1 && cur.length >= maxWidth) break;
        }
        if (cur && lines.length < maxLines) lines.push(cur);
        if (!lines.length) return [name.slice(0, maxWidth)];
        return lines.slice(0, maxLines);
      }
      function makeHighScoreLines(entry) {
        const nameLines = wrapName(entry.name, COLS, 2);
        const scoreLine = String(entry.score);
        return [...nameLines, scoreLine];
      }
      function nextAttractMsg() {
        if (!attrIter) attrIter = makeAttractQueue();
        const n = attrIter.next();
        if (n.done) { attrIter = null; return BANNER; }
        return n.value;
      }
      function startAttract(lines = BANNER) {
        state = State.ATTRACT;
        grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        current = { shape: null, color: null, row: 0, col: 3 };
        score = 0; setScoreUI(); renderStats();
        attrMsg = lines.slice();
        attrX = COLS;
        attrY = centerY(attrMsg.length);
        attrMode = 'scroll';
        attrColor = randColor();
        attrTimer = 0; attrPauseTimer = 0;
      }
      function updateAttract(dt) {
        attrTimer += dt;
        if (attrTimer < ATTR_TICK) return;
        attrTimer = 0;

        if (attrMode === 'scroll') {
          const targetX = centerXFor(attrMsg);
          if (attrX > targetX) attrX--;
          else { attrMode = 'drop'; }
        } else {
          attrY++;
          if (attrY > ROWS) {
            // pause between messages
            attrPauseTimer += ATTR_TICK;
            if (attrPauseTimer >= ATTR_PAUSE) {
              attrPauseTimer = 0;
              const next = nextAttractMsg();
              startAttract(next);
            }
          }
        }
      }

      // ---------- Fireworks ----------
      function fireworksOnce() {
        const cv = fireworksCV, ctx = cv.getContext('2d');
        cv.width = innerWidth; cv.height = innerHeight; cv.style.display = 'block';
        const parts = [], cols = ['#ff5252', '#ffd700', '#00e6ff', '#a259f7', '#00d100', '#ff7f00'];
        function burst() {
          const x = Math.random() * cv.width * 0.6 + cv.width * 0.2;
          const y = Math.random() * cv.height * 0.3 + cv.height * 0.2;
          const color = cols[Math.floor(Math.random() * cols.length)];
          for (let i = 0; i < 32; i++) {
            const a = (Math.PI * 2 * i) / 32, s = Math.random() * 4 + 2;
            parts.push({ x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s, a1: 1, color });
          }
        }
        for (let i = 0; i < 3; i++) burst();
        let frame = 0;
        (function anim() {
          ctx.clearRect(0, 0, cv.width, cv.height);
          for (const p of parts) {
            ctx.globalAlpha = p.a1;
            ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, 2 * Math.PI);
            ctx.fillStyle = p.color; ctx.fill();
          }
          for (const p of parts) {
            p.x += p.vx; p.y += p.vy; p.vx *= .96; p.vy = p.vy * .96 + .05; p.a1 *= .96;
          }
          frame++;
          if (frame < 60) requestAnimationFrame(anim);
          else cv.style.display = 'none';
        })();
      }

      // ---------- High Scores ----------
      function getDefaultHighScores() {
        return [
          { name: 'Paul Atreides', score: 12840 },
          { name: 'Ender Wiggin', score: 11320 },
          { name: 'Hari Seldon', score: 10680 },
          { name: 'Valentine Michael Smith', score: 9950 },
          { name: 'Case', score: 9420 },
          { name: 'R. Daneel Olivaw', score: 8870 },
          { name: 'Gully Foyle', score: 8450 },
          { name: 'Trillian', score: 7930 },
          { name: 'Rick Deckard', score: 7610 },
          { name: 'Mark Watney', score: 7240 },
        ];
      }
      function updateHighScoresUI() {
        const ol = $('#highScores');
        ol.innerHTML = highScores.map(s => `
      <li>
        <span style="text-align:left;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:120px;"><b>${escapeHtml(s.name)}</b></span>
        <span style="text-align:right;min-width:60px;display:inline-block;font-variant-numeric:tabular-nums;">${s.score}</span>
      </li>`).join('');
      }
      function encodeScores(scores) {
        const json = JSON.stringify(scores);
        return btoa(String.fromCharCode(...new TextEncoder().encode(json)));
      }
      function decodeScores(str) {
        try {
          const bytes = Uint8Array.from(atob(str), c => c.charCodeAt(0));
          return JSON.parse(new TextDecoder().decode(bytes));
        } catch { return []; }
      }
      function saveHighScore(entry) {
        highScores.push(entry);
        highScores.sort((a, b) => b.score - a.score);
        if (highScores.length > 10) highScores.length = 10;
        updateHighScoresUI();
        localStorage.setItem('tetrisHighScores', JSON.stringify(highScores));
        const ta = $('#highScoresData'); if (ta) ta.value = encodeScores(highScores);
      }
      function addHighScore(newScore) {
        if (newScore <= 0) return;
        if (autoPlay) saveHighScore({ name: 'AI', score: newScore });
        else { pendingScore = newScore; showNamePrompt(); }
      }
      function loadHighScores() {
        const ta = $('#highScoresData');
        let loaded = false;
        if (ta && ta.value) {
          const dec = decodeScores(ta.value);
          if (Array.isArray(dec) && dec.length) { highScores = dec; loaded = true; }
        }
        if (!loaded) {
          try {
            const data = localStorage.getItem('tetrisHighScores');
            if (data) {
              const parsed = JSON.parse(data);
              if (Array.isArray(parsed) && parsed.length) { highScores = parsed; loaded = true; }
            }
          } catch { }
        }
        if (!loaded) {
          highScores = getDefaultHighScores();
          localStorage.setItem('tetrisHighScores', JSON.stringify(highScores));
          if (ta) ta.value = encodeScores(highScores);
        }
        highScores.sort((a, b) => b.score - a.score);
        if (highScores.length > 10) highScores.length = 10;
        updateHighScoresUI();
      }

      // ---------- Input / UI ----------
      function showNamePrompt() {
        const wrap = $('#playerNamePrompt');
        wrap.style.display = 'flex';
        $('#playerNameInput').value = '';
        setTimeout(() => $('#playerNameInput').focus(), 50);
      }
      function hideNamePrompt() {
        $('#playerNamePrompt').style.display = 'none';
      }

      function bindUI() {
        $('#btnNew').addEventListener('click', startNewGame);
        autoBtn.addEventListener('click', () => {
          autoPlay = !autoPlay;
          autoBtn.textContent = autoPlay ? 'Stop Auto Play' : 'Auto Play';
          aiTarget = null;
        });

        $('#btnLeft').addEventListener('mousedown', () => { if (state === State.PLAYING) { tryMove(-1); drawBoard(); } });
        $('#btnRight').addEventListener('mousedown', () => { if (state === State.PLAYING) { tryMove(1); drawBoard(); } });
        $('#btnRotate').addEventListener('mousedown', () => { if (state === State.PLAYING) { tryRotate(); drawBoard(); } });
        $('#btnDrop').addEventListener('mousedown', () => { if (state === State.PLAYING) { hardDrop(); drawBoard(); } });

        document.querySelectorAll('input[name="speedMode"]').forEach(r => {
          r.addEventListener('change', function () { if (this.checked) { setSpeed(this.value); } });
        });

        $('#btnNameOk').addEventListener('click', () => {
          const name = ($('#playerNameInput').value || 'Player').trim();
          hideNamePrompt();
          if (pendingScore != null) {
            saveHighScore({ name, score: pendingScore });
            pendingScore = null;
            enterAttract();
          }
        });

        // keyboard
        window.addEventListener('keydown', e => {
          if (state !== State.PLAYING) return;
          if (e.key === 'ArrowLeft' || e.key === 'a') { tryMove(-1); drawBoard(); }
          else if (e.key === 'ArrowRight' || e.key === 'd') { tryMove(1); drawBoard(); }
          else if (e.key === 'ArrowUp' || e.key === 'w') { tryRotate(); drawBoard(); }
          else if (e.key === 'ArrowDown' || e.key === 's') { dropStep(); drawBoard(); }
          else if (e.key === ' ') { hardDrop(); drawBoard(); }
        });

        // mouse drag (simple)
        let dragging = false, startX = 0, startCol = 0, startY = 0, dropped = false;
        boardCV.addEventListener('mousedown', e => {
          if (e.button !== 0 || state !== State.PLAYING) return;
          dragging = true; startX = e.clientX; startY = e.clientY; startCol = current.col; dropped = false;
        });
        window.addEventListener('mousemove', e => {
          if (!dragging || state !== State.PLAYING) return;
          const dx = e.clientX - startX, dy = e.clientY - startY;
          const moveBy = Math.round(dx / CELL);
          const newCol = clamp(startCol + moveBy, 0, COLS - 1);
          if (newCol !== current.col && canPlaceAt(current.shape, current.row, newCol)) { current.col = newCol; drawBoard(); }
          if (!dropped && dy > 30) { hardDrop(); drawBoard(); dropped = true; dragging = false; }
        });
        window.addEventListener('mouseup', () => dragging = false);
        boardCV.addEventListener('wheel', e => { e.preventDefault(); if (state === State.PLAYING) { tryRotate(); drawBoard(); } }, { passive: false });

        // reset scores
        $('#resetHighScoresBtn').addEventListener('click', () => {
          highScores = getDefaultHighScores(); updateHighScoresUI();
          localStorage.setItem('tetrisHighScores', JSON.stringify(highScores));
          const ta = $('#highScoresData'); if (ta) ta.value = encodeScores(highScores);
        });
      }

      // ---------- Modes ----------
      function startNewGame() {
        state = State.PLAYING;
        grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        current = { shape: null, color: null, row: 0, col: 3 };
        score = 0; shapesSeen = 0; linesCompleted = 0; tetrises = 0; lineBonusMultiplier = 1;
        setScoreUI(); renderStats();
        next = null; spawnPiece(); drawNext();
      }
      function enterAttract() { startAttract(BANNER); }

      // ---------- Loop ----------
      function loop(ts) {
        const dt = lastTs ? (ts - lastTs) : 0;
        lastTs = ts;

        if (state === State.ATTRACT) {
          updateAttract(dt);
          drawAttract();
        } else if (state === State.PLAYING) {
          // AI plan & micro-actions
          aiStep(dt);

          // gravity
          gravityAccum += dt;
          const gStep = gravityMs();
          while (gravityAccum >= gStep) {
            gravityAccum -= gStep;
            dropStep();
          }
          drawBoard();
        }

        rafId = requestAnimationFrame(loop);
      }

      // ---------- Init ----------
      function init() {
        document.documentElement.style.setProperty('--cols', COLS);
        document.documentElement.style.setProperty('--rows', ROWS);

        bindUI();
        loadHighScores();
        setSpeed('Slow');
        setScoreUI();
        renderStats();
        // start in attract mode automatically
        enterAttract();

        // seed next so preview shows before first game
        next = SHAPES[Math.floor(Math.random() * SHAPES.length)];
        drawNext();

        cancelAnimationFrame(rafId);
        lastTs = 0; rafId = requestAnimationFrame(loop);
      }

      // Run immediately on load
      init();
    })();
  </script>
</body>

</html>